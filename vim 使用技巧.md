### vim 使用技巧

## 结识**.**范式

**.** 命令可以让我们重复上次的修改

- 什么是修改?

  **x** 命令会删除光标下的字符，在这种情况下使用**.**命令“重复上次修改”时， 会让 Vim 删除光标下的字符.

  **dd** 命令也做删除操作，但它会把整行一起删掉。如果在**dd**后使用**.**命令，那么“重复上次修改”会让 Vim 删除当前行.

  **>G** 命令会增加从当前行到文档末尾处的缩进层级。如果我们在此命令后使 用**.**命令，那么“重复上次修改”会让 Vim 增加从当前行到文档末尾的缩进层级。

  每次我们进入插入模式 时，也会形成一次修改。从进入插入模式的那一刻起（例如，输入 i），直到返回普通 模式时为止（输入<Esc>），Vim 会记录每一个按键操作。做出这样一个修改后再用 . 命 令的话，它将会重新执行所有这些按键操作.

### 技巧 2 不要自我重复

> 对于在行尾添加内容这样的常见操作，如添加分号，Vim 提供了一个专门的命令， 可以把两步操作合并为一步。

#### 减少无关的移动

假设有如下的 JavaScript 程序片段：

```js
he_vim_way/2_foo_bar.js
var foo = 1 
var bar = 'a' 
var foobar = foo + bar
```

我们想在每行的结尾添加一个分号。

* 基础使用:要实现这一点，先得把光标移到行尾，然后切换 到插入模式进行修改。**$** 命令可以完成移动动作，接着就可以执行 a;<Esc> 完成修改了。由于 **.** 命令可以重复上次的修改，因此我们不必重复之前的 操作，而是执行两次 **j$.**。一个键（**.**）顶 3 个（**a;<Esc>**）。

* 终极使用:通过用**A**来代替**$a**大大提升了**.**命令的效率。我们不必再把光标移到行 尾，只需保证它位于该行内就行了（可在任意位置）。执行足够多次 的 **j.** ，完成对后续行的修改。

### 技巧 3 以退为进

> 我们可以用一种常用的 Vim 操作习惯在一个字符前后各添加一个空格。乍一看， 这种方法有点古怪，不过其好处是可重复，这将使我们可以事半功倍地完成工作。

假设有一行代码看起来是这样的：

```js
the_vim_way/3_concat.js
var foo = "method("+argument1+","+argument2+")";
```

在 JavaScript 里把字符串连接到一起从来都不美观，但我们可以像下面这样在 + 号前后各添加一个空格，让肉眼更容易识别：

```js
var foo = "method(" + argument1 + "," + argument2 + ")";
```

#### 使修改可重复

**f{char}** 命令让 Vim 查找下一处指定字符出现的位 置，如果找到了，就直接把光标移到那里（参见 :h f ）。因此，当我们输入 **f+** 时， 光标会直接移到下一个 **+** 号所在的位置。

**s** 命令把两个操作合并为一个：它先删除光标下的字符，然后进入插入模式。在 删除 **+** 号后，我们先输入**␣+␣**，然后退出插入模式。

完成第一处修改后，我们可以重复按 **f+** 命令跳到下一个 **+** 号所在的位置。不过， 还有一种更好的方法可以用。**;** 命令会重复查找上次 **f** 命令所查找的字符，不小心按了太多次**;**键，就会偏离我们的目标。不过我们可以再按 **,** 键跳回去，这个命令会反方向查找上次 **f{char}** 所查找的字符,因此我们用不着输入 4 次 **f+**，而是只用输入一次，后面跟着再用 3 次 **;** 命令。

**;** 命令带我们到下一个目标字符上，而 **.** 命令则重复上次的修改。因此，我们可 以连续输入 3 次 **;.** 来完成全部修改。

### 技巧 4 执行、重复、回退

> 在面对重复性工作时，我们需要让移动动作和修改都能够重复，这样就可以达到 一个最佳编辑模式。Vim 对此的支持是：它会记住我们的操作，并使最常用的操作触手可及，所以我们可以很方便地重复执行它们。本节将介绍 Vim 可以重复执行的每个操作，并学习如何回退这些命令。
>

##### 表 1-1 可重复的操作及如何回退

| 目的                     | 操作                  | 重复 | 回退 |
| ------------------------ | --------------------- | ---- | ---- |
| 做出一个修改             | {edit}                | .    | u    |
| 在行内查找下一指定字符   | f{char}/t{char}       | ;    | ,    |
| 在行内查找上一指定字符   | F{char}/T{char}       | ;    | ,    |
| 在文档中查找下一处匹配项 | /pattern<CR>          | n    | N    |
| 在文档中查找上一处匹配项 | ?pattern<CR>          | n    | N    |
| 执行替换                 | :s/target/replacement | &    | u    |
| 执行一系列修改           | qx{changes}q          | @x   | u    |

### 技巧 5 查找并手动替换

> Vim 提供了一个:substitute 命令专门用于查找替换任务，不过用上面介绍的技术，我们也可以手动修改第一处地方，然后再一个个地查找替换其他匹配项。**.** 命令可以把我们从繁重的工作中解放出来，而即将登场的另一个有用的单键命令，则能够让我们方便地在匹配项间跳转。

在下面这段文本中，每一行都出现了单词“content”：

```txt
the_vim_way/1_copy_content.txt
...We're waiting for content before the site can go live... ...If you are content with this, let's go ahead with it... ...We'll launch as soon as we have the content...
```

#### 偷懒的办法：无需输入就可以进行查找

我们可以简单地把光标移到“content”这个单词上，然后使用 **\*** 命令对它进行查找。执行过一次查找“content”的命令后，现在我们只需按 n 键就可以跳到下一个匹配项。

#### 使修改可重复

当光标位于“content”的开头时，我们就可以着手修改它。这包括两步操作：首先要删除单词“content”，然后输入替代的单词。**cw** 命令会删除从光标位置到单词结 尾间的字符，并进入插入模式，接下来我们就可以输入单词“copy”了。Vim 会把我 们离开插入模式之前的全部按键操作都记录下来，因此整个 **cw**copy<Esc> 会被当成一 个修改。也就是说，执行 **.** 命令会删除从光标到当前单词结尾间的字符，并把它修改 为“copy”。可以再次按 n 移到下一个地方，如此循环往复，直到完成全部的修改。

